use std::env;
use std::fs;
use std::io::Write;
use std::path::Path;

use cache::Cache;
use cache::Update;
use octocrab::Octocrab;

use reposcrape::query::{github::GHQuery, query::QueryInterface};
use cache::ExpandedRepoCache;

mod cache;
mod color;
mod date;
mod reposcrape;

fn html_test() {
    // Define the directory and file paths
    let out_dir = "./public";
    let index_path = &format!("{}/index.html", out_dir);

    // Use the GitHub token
    let _github_token = env::var("GITHUB_TOKEN").expect("No GitHub token in env");

    // Create the directory if it doesn't exist
    if !Path::new(out_dir).exists() {
        fs::create_dir_all(out_dir).expect("Failed to create output directory");
    }

    // Define the content for the index.html
    let html_content = r#"
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>repo-scraper</title>
        </head>
        <body>
            <h1>Sup, I changed this text because I wanted to see if it updates correctly ðŸ˜Ž</h1>
            <p>This is a test site generated by a Rust program.</p>
        </body>
        </html>
        "#;

    // Write the content to the index.html file
    let mut file = fs::File::create(index_path).expect("Failed to create index.html file");
    file.write_all(html_content.as_bytes())
        .expect("Failed to write to index.html file");

    println!("Static site generated successfully at {}", index_path);
}

async fn color_test() {
    match color::fetch_language_colors().await {
        Ok(language_colors) => {
            for (lang, color) in language_colors {
                println!("{}: {}", lang, color);
            }
        }
        Err(e) => eprintln!("Error fetching language colors: {}", e),
    }
}

// fn cache_test() {
//     let file_path = "./.cache";

//     // Check if the file already exists
//     if Path::new(file_path).exists() {
//         println!("File already exists: {file_path}");
//         let mut file = fs::OpenOptions::new()
//             .append(true)
//             .open(file_path)
//             .expect("Failed to open .cache file");
//         file.write_all("hello".as_bytes())
//             .expect("Failed to write to file");
//     } else {
//         // Create and write to the file
//         let mut file = fs::File::create(file_path).expect("Failed to create .cache file");
//         file.write_all(b"Hello, this is a sample text.")
//             .expect("Failed to write to file");
//         println!("File written to {file_path}");
//     }
// }

async fn example(cache_file: &str) -> Result<(), Box<dyn std::error::Error>> {
    let mut cache = Cache::load(cache_file);

    if cache.is_empty() || cache.repos.is_outdated() {
        let colors = color::fetch_language_colors().await;

        let octocrab = Octocrab::builder()
            .user_access_token(env::var("GITHUB_TOKEN").expect("No Github token"))
            .build()?;
        let query = GHQuery::new(octocrab);

        let fetched = query.fetch_latest("LeHuman", 8).await?;

        cache.repos.update(&fetched);
        if let Ok(colors) = colors {
            // TODO: Should colors be obtained through query? Or keep this as a general resource?
            cache.colors.update(&colors);
        }
        cache.save(cache_file)?;
    }

    let expanded = ExpandedRepoCache::new(&cache);

    println!("{:#?}", expanded);

    Ok(())
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    color_test().await;
    reposcrape::test::repo::test_repo_create()?;
    cache::test::cache::test_cache_encode_decode()?;
    cache::test::expand_repo::test_expand_cache()?;
    reposcrape::query::test::github::test_github_retrieve().await?;
    example("./.cache").await?;
    html_test();
    Ok(())
}
